/**
 * PDF DOCUMENT GENERATOR
 * 
 * WHAT THIS FILE DOES:
 * - This creates the final beautiful PDF report you can download.
 * - It takes all the brand info, images, and ad ideas and lays them out like a professional presentation.
 * - Supports Indic/Unicode characters by rendering them to images via Browser Canvas.
 */

import { jsPDF } from 'jspdf';
import { NewFormData, AdPillar, World } from '../types.ts';

export const exportStructuredPDF = async (
    brandName: string,
    formData: NewFormData | any,
    pillars: AdPillar[],
    worlds: World[],
    positioning: any,
    selectedWorld?: World | null,
    recommendedPillarIds?: string[],
    salesperson?: string,
    region?: string,
    logoUrl?: string
) => {
    const pdf = new jsPDF('p', 'pt', 'a4');
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 40;
    const maxWidth = pageWidth - (margin * 2);
    let yPos = margin;

    // Helper to render Indic/Unicode text to an image using Browser Canvas
    // Standard PDF fonts don't support Indic scripts; this method ensures they are visible.
    const renderUnicodeToImage = (text: string, width: number, fontSize: number, isBold: boolean, color: string): { dataUrl: string, height: number, width: number } | null => {
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            if (!ctx) return null;

            const scale = 4; // Ultra-high resolution for print quality
            const fontStack = `${isBold ? 'bold ' : ''}${fontSize * scale}px "Inter", "Roboto", "Noto Sans", "Segoe UI", sans-serif`;
            ctx.font = fontStack;

            // Accurate word wrapping for Canvas
            const words = text.split(' ');
            const lines: string[] = [];
            let currentLine = words[0];

            for (let i = 1; i < words.length; i++) {
                const testLine = currentLine + ' ' + words[i];
                const metrics = ctx.measureText(testLine);
                if (metrics.width > width * scale) {
                    lines.push(currentLine);
                    currentLine = words[i];
                } else {
                    currentLine = testLine;
                }
            }
            lines.push(currentLine);

            const lineHeight = fontSize * 1.4 * scale;
            const canvasWidth = width * scale;
            const canvasHeight = lines.length * lineHeight;

            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Re-apply settings after resize
            ctx.font = fontStack;
            ctx.fillStyle = color;
            ctx.textBaseline = 'top';

            lines.forEach((line, idx) => {
                ctx.fillText(line, 0, idx * lineHeight);
            });

            return {
                dataUrl: canvas.toDataURL('image/png'),
                height: lines.length * fontSize * 1.4,
                width: width
            };
        } catch (e) {
            console.error("Failed to render unicode text", e);
            return null;
        }
    };

    const addFooter = () => {
        const footerY = pageHeight - 30;
        if (logoUrl) {
            try {
                // Center-aligned footer logo
                const imgWidth = 40;
                const imgHeight = 16;
                pdf.addImage(logoUrl, 'PNG', (pageWidth / 2) - (imgWidth / 2), footerY - 14, imgWidth, imgHeight);
            } catch (e) {
                // Silent fail
            }
        }
        pdf.setFontSize(8);
        pdf.setFont('helvetica', 'normal');
        pdf.setTextColor('#94a3b8');
        pdf.text('Generated by SPARQ AI', margin, footerY);

        const totalPages = pdf.internal.getNumberOfPages();
        pdf.text(`Page ${totalPages}`, pageWidth - margin - 30, footerY);
    };

    const triggerNewPage = () => {
        addFooter();
        pdf.addPage();
        yPos = margin;
    };

    const checkPageBreak = (requiredSpace: number) => {
        if (yPos + requiredSpace > pageHeight - margin - 50) {
            triggerNewPage();
            return true;
        }
        return false;
    };

    const addText = (text: string, fontSize: number, isBold: boolean = false, color: string = '#000000', customX?: number, customWidth?: number) => {
        if (!text) return;

        const targetX = customX ?? margin;
        const targetWidth = customWidth ?? (pageWidth - targetX - margin);
        const hasNonLatin = /[^\x00-\x7F]/.test(text);

        if (hasNonLatin) {
            const result = renderUnicodeToImage(text, targetWidth, fontSize, isBold, color);
            if (result) {
                checkPageBreak(result.height + 5);
                pdf.addImage(result.dataUrl, 'PNG', targetX, yPos, targetWidth, result.height);
                yPos += result.height + 10;
                return;
            }
        }

        // Standard English text
        pdf.setFontSize(fontSize);
        pdf.setFont('helvetica', isBold ? 'bold' : 'normal');
        pdf.setTextColor(color);

        const lines = pdf.splitTextToSize(text, targetWidth);
        const lineHeight = fontSize * 1.2;

        lines.forEach((line: string) => {
            if (yPos + lineHeight > pageHeight - margin - 50) {
                triggerNewPage();
            }
            pdf.text(line, targetX, yPos);
            yPos += lineHeight;
        });

        yPos += 5;
    };

    const stripMarkdown = (text: string): string => {
        if (typeof text !== 'string') return '';
        return text
            .replace(/\*\*(.+?)\*\*/g, '$1')
            .replace(/\*(.+?)\*/g, '$1')
            .replace(/_(.+?)_/g, '$1')
            .replace(/`(.+?)`/g, '$1')
            .replace(/#+\s/g, '')
            .replace(/\[(.+?)\]\(.+?\)/g, '$1')
            .trim();
    };

    const addSectionHeader = (title: string) => {
        checkPageBreak(60);
        addText(title, 16, true, '#008080');
        pdf.setDrawColor('#eeeeee');
        pdf.setLineWidth(1);
        pdf.line(margin, yPos, pageWidth - margin, yPos);
        yPos += 20;
    };

    // --- Generate Document ---

    // 0. Title & Header
    addText(brandName || 'Untitled Brand', 24, true, '#333333');
    yPos += 15;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    pdf.setTextColor('#666666');

    const now = new Date();
    const istOffset = 5.5 * 60 * 60 * 1000;
    const istTime = new Date(now.getTime() + istOffset);
    const dateStr = istTime.toISOString().replace('T', ' ').substring(0, 19) + ' IST';
    pdf.text(`Generated: ${dateStr}`, margin, yPos);
    yPos += 15;

    if (salesperson) {
        const salesText = `Salesperson: ${salesperson}${region ? ` (${region})` : ''}`;
        addText(salesText, 10, false, '#666666');
    }
    yPos += 5;

    pdf.setDrawColor('#333333');
    pdf.setLineWidth(2);
    pdf.line(margin, yPos, pageWidth - margin, yPos);
    yPos += 40;

    // 1. Brand Information
    addSectionHeader('1. Brand Information');

    const addFormField = (key: string, value: any, indent: number = 0) => {
        if (!value || key === 'images' || key.includes('Example') || key === 'raw_form_data' || key === 'fullTranscript') return;

        const indentPx = indent * 15;
        const label = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()).replace(/_/g, ' ');

        if (typeof value === 'object' && !Array.isArray(value)) {
            checkPageBreak(30);
            addText(label + ':', 12, true, '#008080');
            Object.entries(value).forEach(([nestedKey, nestedValue]) => {
                addFormField(nestedKey, nestedValue, indent + 1);
            });
            yPos += 5;
        } else {
            checkPageBreak(25);
            pdf.setFontSize(11);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor('#555555');
            pdf.text(label + ':', margin + indentPx, yPos);

            const displayVal = Array.isArray(value) ? value.filter(Boolean).join(', ') : String(value);
            const valueX = margin + 200;
            const valueWidth = pageWidth - valueX - margin;

            // Render value safely (potential Unicode)
            // Save current yPos to ensure label and value start on same line
            const currentY = yPos;
            addText(displayVal, 11, false, '#000000', valueX, valueWidth);

            // If addText moved yPos significantly, fine. If not, ensure minimum spacing.
            if (yPos === currentY) yPos += 20;
        }
    };

    Object.entries(formData).forEach(([key, value]) => {
        addFormField(key, value, 0);
    });

    // 2. Positioning
    if (positioning) {
        triggerNewPage();
        addSectionHeader('2. Positioning Statement');

        const posText = typeof positioning === 'string' ? positioning : (positioning.english_positioning || positioning.hindi_positioning || '');
        const cleanedText = stripMarkdown(posText);
        const hasNonLatin = /[^\x00-\x7F]/.test(cleanedText);

        if (hasNonLatin) {
            addText(cleanedText, 12, false, '#000000');
        } else {
            const lines = pdf.splitTextToSize(cleanedText, maxWidth - 30);
            const boxHeight = (lines.length * 15) + 30;
            checkPageBreak(boxHeight + 10);

            pdf.setFillColor('#f9f9f9');
            pdf.rect(margin, yPos, maxWidth, boxHeight, 'F');
            pdf.setDrawColor('#008080');
            pdf.setLineWidth(4);
            pdf.line(margin, yPos, margin, yPos + boxHeight);

            pdf.setFontSize(12);
            pdf.setFont('helvetica', 'italic');
            pdf.setTextColor('#000000');

            let textY = yPos + 22;
            lines.forEach((line: string) => {
                pdf.text(line, margin + 15, textY);
                textY += 15;
            });
            yPos = textY + 20;
        }
    }

    // 3. Worlds
    if (worlds && worlds.length > 0) {
        triggerNewPage();
        addSectionHeader('3. Generated Worlds');

        worlds.forEach((w, i) => {
            checkPageBreak(80);
            const isSelected = selectedWorld && (
                (w.id && selectedWorld.id && w.id === selectedWorld.id) ||
                (w.title && selectedWorld.title && w.title.trim() === selectedWorld.title.trim())
            );
            const isRecommended = w.recommended;

            const titleColor = isSelected ? '#4f46e5' : isRecommended ? '#059669' : '#333333';
            let titleText = `3.${i + 1} ${w.title}`;
            if (isSelected) titleText += ' (Active Selection)';
            else if (isRecommended) titleText += ' (Recommended)';

            addText(titleText, 13, true, titleColor);
            addText(w.description, 11, false, '#444444');

            if (isRecommended && w.recommendationReason) {
                checkPageBreak(40);
                addText('Recommendation Reason:', 10, true, '#059669');
                addText(w.recommendationReason, 10, false, '#059669');
            }
            yPos += 15;
        });
    }

    // 4. Ad Pillars
    if (pillars && pillars.length > 0) {
        triggerNewPage();
        addSectionHeader('4. Ad Pillars');

        if (pillars[0].functional_problem_source) {
            addText('Functional Problem:', 12, true, '#333333');
            addText(pillars[0].functional_problem_source, 11, false, '#444444');
            yPos += 10;
        }

        pillars.forEach((p, pIdx) => {
            checkPageBreak(120);
            const pillarName = p.pillar_name || p.pillar_id || p.name || p.maslow_level || 'Untitled Pillar';
            const isRecommended = recommendedPillarIds && recommendedPillarIds.includes(p.pillar_id || '');

            pdf.setFillColor(isRecommended ? '#ecfdf5' : '#f8fafc');
            pdf.roundedRect(margin, yPos, maxWidth, 35, 3, 3, 'F');

            const pillarTitleText = `Pillar ${pIdx + 1}: ${pillarName}${isRecommended ? ' (RECOMMENDED)' : ''}`;
            const pillarTitleColor = isRecommended ? '#059669' : '#475569';

            // Adjust yPos temporarily for the box content
            const oldY = yPos;
            yPos += 22;
            addText(pillarTitleText, 12, true, pillarTitleColor, margin + 12, maxWidth - 24);
            yPos = oldY + 50;

            if (p.life_problem || p.lifestyle_problem) {
                addText('Life Problem:', 11, true, '#1e293b');
                addText(p.life_problem || p.lifestyle_problem || '', 11, false, '#475569');
            }

            if (p.hook_world_snapshot) {
                addText('Hook World Snapshot:', 11, true, '#1e293b');
                addText(p.hook_world_snapshot, 11, false, '#475569');
            }

            if (isRecommended && p.recommendationReason) {
                addText('Why Recommended:', 11, true, '#059669');
                addText(p.recommendationReason, 11, true, '#059669');
            }
            yPos += 10;
        });
    }

    // 5. Stories
    const allStories = pillars.flatMap((p) => (p.stories || []).map(s => ({ ...s, pillarName: p.pillar_name || p.pillar_id || p.name })));
    if (allStories.length > 0) {
        triggerNewPage();
        addSectionHeader('5. Generated Stories');

        allStories.forEach((s, sIdx) => {
            checkPageBreak(150);
            const storyTitle = s.title || s.genre || 'Untitled Story';
            const hasNonLatin = /[^\x00-\x7F]/.test(storyTitle + (s.story || '') + (s.overview || ''));

            // FIX: Use addText for story titles to support Unicode/Indic languages
            addText(`5.${sIdx + 1} ${storyTitle}`, 13, true, '#334155');

            // Metadata
            addText(`Aligned with Pillar: ${s.pillarName}`, 10, true, '#64748b');
            yPos += 5;

            if (s.overview) {
                addText('Overview:', 11, true, '#333333');
                addText(s.overview, 10, false, '#475569');
            }

            if (s.story) {
                addText('Narrative:', 11, true, '#333333');
                addText(s.story, 10, false, '#475569');
            } else if (s.frames && s.frames.length > 0) {
                addText('Frames:', 11, true, '#333333');
                s.frames.forEach((f: any, fIdx: number) => {
                    checkPageBreak(40);
                    const frameText = typeof f === 'string' ? f : `[${f.frame_no || fIdx + 1}] ${f.visual_action || f.scene || ''} ${f.audio_dialogue || f.dialogue || ''}`;
                    addText(frameText, 9, false, '#475569');
                });
            }

            if (s.ending_moment) {
                addText('Closing Moment:', 11, true, '#333333');
                addText(s.ending_moment, 10, false, '#475569');
            }

            if (s.tagline) {
                addText('Tagline:', 11, true, '#0f172a');
                addText(s.tagline, 11, true, '#0369a1');
            }

            if (hasNonLatin) {
                pdf.setFontSize(8);
                pdf.setFont('helvetica', 'italic');
                pdf.setTextColor('#94a3b8');
                pdf.text('* This story contains translated content. View in app for non-English scripts.', margin, yPos);
                yPos += 15;
            }
            yPos += 20;
        });
    }

    addFooter(); // Final page footer
    pdf.save(`SPARQ-${brandName.replace(/\s+/g, '-')}-${new Date().toISOString().slice(0, 10)}.pdf`);
};
