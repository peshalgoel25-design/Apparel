# SPARQ Architecture Documentation

This document provides a comprehensive overview of the SPARQ application architecture, designed to enable a developer to recreate the system from scratch.

## 1. High-Level Overview

SPARQ is a React-based web application that facilitates brand positioning and ad creative generation using AI. It follows a modular architecture with a clear separation between the UI (React), business logic (Hooks/Utils), and the AI "brain" (External Webhooks).

### Core Stack
- **Framework**: React 18/19 (TypeScript)
- **Styling**: Tailwind CSS
- **State Management**: React `useState` and `useEffect` with LocalStorage persistence.
- **AI Integration**: External `n8n` webhooks and Google Gemini API.
- **Asset Handling**: Vite for bundling and asset management.

## 2. System Components

### A. Frontend (UI/UX)
Located in `components/` and `App.tsx`:
- **Main Controller (`App.tsx`)**: Manages the global state, session handling, and high-level routing (Category Selection -> Form -> Positioning -> Worlds -> Ad Pillars).
- **Forms (`BrandForm.tsx`, `QuestionRenderer.tsx`)**: Dynamic questionnaires for FMCG and Industrial sectors. Supports multi-language and voice-to-text input.
- **Positioning (`PositioningStatement.tsx`)**: Displays and allows editing of the AI-generated brand positioning.
- **Creative Hub (`AdCreative.tsx`)**: Visualizes the ad pillars and storyboards generated by the AI.

### B. Business Logic (Hooks)
Located in `hooks/`:
- **`useWorldOperations.ts`**: Handles the generation, analysis, and ranking of "Brand Worlds."
- **`usePillarOperations.ts`**: Orchestrates the creation of ad pillars and storylines, including versioning and translation.

### C. Utilities & Services
Located in `utils/`:
- **`utils.ts`**: General helper functions for data transformation, category inference (FMCG vs Industrial), and data cleaning.
- **`api.ts`**: Handles low-level HTTP requests to webhooks and Google Gemini.
- **`pdfGenerator.ts`**: Uses `jspdf` and `html2canvas` to generate professional brand strategy documents.

## 3. Data Flow

1.  **Input Phase**: User fills in questionnaires or uploads voice notes. Voice notes are transcribed via Gemini.
2.  **Structuring Phase**: App-side logic (`utils.ts`) prepares the raw form data into a structured JSON payload.
3.  **Inference Phase**: Data is sent to the `n8n` production/test webhooks.
    - `generate_description`: Returns a brand positioning statement.
    - `generate_worlds`: Returns artistic "worlds" the brand fits into.
    - `generate_pillars`: Returns ad pillars based on selection.
    - `generate_story`: Returns full ad scripts/storyboards.
4.  **Refinement Phase**: Users edit, translate, or generate images for stories.
5.  **Output Phase**: Final data is persisted to LocalStorage and can be exported via PDF.

## 4. Webhook Contract

Webhooks expect a standardized POST payload:
```json
{
  "action": "ACTION_NAME",
  "form_data": { ... },
  "session_id": "session_xxx"
}
```
Actions include: `generate_description`, `generate_worlds`, `generate_pillars`, `generate_story`, etc.

## 5. UI/UX Principles

- **Premium Aesthetics**: Use of gradients, smooth transitions (`animate-fade-in`), and glassmorphism.
- **Responsive Design**: Mobile-first layout using Tailwind's grid and flexbox.
- **Immediate Feedback**: Pulse animations and loading spinners for all async AI operations.

## 6. Setup & Deployment

1.  **Environment**: Create a `.env.local` with `VITE_GEMINI_API_KEY`.
2.  **Dependencies**: Install `react`, `react-dom`, `jspdf`, `html2canvas`, `jszip`, and `@google/genai`.
3.  **Build**: Use `vite build` for production bundles.
4.  **Assets**: Place the logic and assets in the `assets/` folder to ensure proper bundling.
